При реализации многопоточности в Python выяснил, что существует 2 типа задач: cpu_bound и i/o_bound. 

Cpu_bound задачи - это задачи, которые требуют выполнения вычислений, но не связаны с вводом/выводом.
В качестве cpu_bound задачи взял интрегрирование функции на заданном отрезке. Отрезок интегрирования 
поделил на n частей и раскидал их на потоки, где n - число потоков. Также выполнил 2 реализации: 
первая, когда результирующая переменная(результат интегрирования) является общей перемнной, и второй,
когда у каждого потока локальная переменная результата. И первая и вторая реализация медленнее нежели
когда выполняется один поток(2 реализация оказалась быстрее 1, т.к. не требовался объект синхронизации).
Ускорения не произошло из за GIL. GIL это механизм, не допускающий, чтобы в любой момент выполнялось 
более одного потока в Python. В связи с этим cpu_bound задачи не распараллеливаются при многопоточности.
Для распараллеливания данного вида задач лучше использовать многопроцессность (библиотека multiprocessing), 
также код, написанный на С или использовать операции ввода/вывода,т.к. в этом случае GIL снимается.

I/O_bound задачи, ориентированные на ввод/вывод, предполагают считывание данных или запись их на устройство,
запрос к базе данных, ввод данных пользователем. В качестве i/o_bound задачи реализовывал открытие файла 
и считывания его данных, также открытие файла и подсчет хеш суммы файла. При первом варианте оказалось,
что существует оптимальное число потоков, при котором достигается минимальное время выполнения, а во втором
случае ускорить процесс не удалось. 

При реализации использовал модуль threading (самостоятельно раскидывал куски задачи на потоки). 
Также можно использовать пул потоков, в этом случае у нас есть набор подзадач, которые постепенно
распределяются между потоками по мере их выполнения(ThreadPoolExecutor). Главное отличие заключается в том, 
что в пул потоках после выполнения задачи поток не уничтожается, а берет новую задачу, если очередь задач
не пуста.